# Head First Design Patterns
<li>https://github.com/bethrobson/Head-First-Design-Patterns 作者 github</li>

# 第一章 - 介紹設計模式-歡迎到來設計模式
<li>1.介紹設計模式</li>
<li>2.類別與次類別之間的關係</li>
<li>3.繼承的缺失</li>
<li>4.把會變動的部分取出並「封裝」起來，好讓其他部份部受到影響。程式碼變動之後，出其不意的部分會變少，系統會變更有彈性。</li>
<li>5.分開變動和不會變動的部分</li>
<li>6.設計守則：寫程式是針對介面寫，而不是針對實踐方式寫</li>
<li>7.「寫程式是針對介面寫」真正的意思是「寫程式是針對超型態(supertype)而寫」</li>
<li>8.動態地設計行為</li>
<li>9.行為封裝的大局觀</li>
<li>10.設計守則：多用合成，少用繼承</li>
<li>11.「策略模式」：定義了演算法家族，個別封裝起來，讓它們之間可以互相替換。此模式讓演算法的變動，不會影響到使用演算法的程式</li>
<li>12.共通模式詞彙</li>

# 第二章 - 觀察者模式
<li>1.實做題目的需求</li>
<li>2.知道目前可以得到哪些資訊</li>
<li>3.認識觀察者模式</li>
<li>4.觀察者模式簡單定義：報社與訂閱者的關係，但報社有更新報紙就會給予訂閱者通知，反之沒有訂閱的就不會收到通知。</li>
<li>5.定義觀察者模式</li>
<li>6.觀察者模式類別圖</li>
<li>7.鬆綁</li>
<li>8.主題和觀察者的關係</li>
<li>9.使用 java 內建的觀察者模式</li>
<li>10.在 JDK 中找到觀察者模式</li>

# 第三章 - 裝飾者模式-裝飾物件
<li>1.類別爆炸時應該怎麼去規劃</li>
<li>2.開放關閉守則：類別開放以方便擴充，關閉禁止修改</li>
<li>3.認識裝飾者模式</li>
<li>4.定義裝飾者模式</li>
<li>5.真實世界的裝飾者 java I/O</li>
<li>6.設計自己的 java I/O 裝飾者</li>

# 第四章工廠模式
<li>1.思考 new</li>
<li>2.實作範例</li>
<li>3.封裝建立物件</li>
<li>4.將會變動的程式碼封裝到另外一個物件中，交由這個物件去專門處理，我們稱這新物件為工廠。</li>
<li>5.定義簡單工廠</li>
<li>6.給衍生類別使用的框架</li>
<li>7.允許次類別做決定</li>
<li>8.藉由工廠方法，鬆綁超類別與次類別的關係</li>
<li>9.平行的類別階層</li>
<li>10.定義工廠方法模式：定義了一個建立物件的介面，但由次類別決定要實體化的類別為何者。工廠方法讓類別把實體化的動作，交由次類別進行。</li>
<li>11.顛覆依賴守則：依賴抽象類別，不依賴具象類別</li>
<li>A：變數不可持有具象類別的參考</li>
<li>B：不可讓類別繼承自具象類別</li>
<li>C：不可讓次類別中的方法 override 超類別的方法</li>
<li>12.定義抽象工廠模式：提供一個介面，建立相關或者相依物件之家族，而不需要明確指定具象類別</li>
<li>13.抽象工廠模式與工廠模式的不同</li>
<li>14.依賴抽象，不依賴具象類別</li>
<li>參考網址：https://wickedlysmart.com/headfirstdesignpatterns/code.html</li>

