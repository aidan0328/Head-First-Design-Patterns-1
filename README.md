# Head First Design Patterns
<li>https://github.com/bethrobson/Head-First-Design-Patterns 作者 github</li>

# 第一章 - 介紹設計模式-歡迎到來設計模式
<li>1.介紹設計模式</li>
<li>2.類別與次類別之間的關係</li>
<li>3.繼承的缺失</li>
<li>4.把會變動的部分取出並「封裝」起來，好讓其他部份部受到影響。程式碼變動之後，出其不意的部分會變少，系統會變更有彈性。</li>
<li>5.分開變動和不會變動的部分</li>
<li>6.設計守則：寫程式是針對介面寫，而不是針對實踐方式寫</li>
<li>7.「寫程式是針對介面寫」真正的意思是「寫程式是針對超型態(supertype)而寫」</li>
<li>8.動態地設計行為</li>
<li>9.行為封裝的大局觀</li>
<li>10.設計守則：多用合成，少用繼承</li>
<li>11.「策略模式」：定義了演算法家族，個別封裝起來，讓它們之間可以互相替換。此模式讓演算法的變動，不會影響到使用演算法的程式</li>
<li>12.共通模式詞彙</li>

# 第二章 - 觀察者模式
<li>1.實做題目的需求</li>
<li>2.知道目前可以得到哪些資訊</li>
<li>3.認識觀察者模式</li>
<li>4.觀察者模式簡單定義：報社與訂閱者的關係，但報社有更新報紙就會給予訂閱者通知，反之沒有訂閱的就不會收到通知。</li>
<li>5.定義觀察者模式</li>
<li>6.觀察者模式類別圖</li>
<li>7.鬆綁</li>
<li>8.主題和觀察者的關係</li>
<li>9.使用 java 內建的觀察者模式</li>
<li>10.在 JDK 中找到觀察者模式</li>

# 第三章 - 裝飾者模式-裝飾物件
<li>1.類別爆炸時應該怎麼去規劃</li>
<li>2.開放關閉守則：類別開放以方便擴充，關閉禁止修改</li>
<li>3.認識裝飾者模式</li>
<li>4.定義裝飾者模式</li>
<li>5.真實世界的裝飾者 java I/O</li>
<li>6.設計自己的 java I/O 裝飾者</li>

# 第四章 - 工廠模式
<li>1.思考 new</li>
<li>2.實作範例</li>
<li>3.封裝建立物件</li>
<li>4.將會變動的程式碼封裝到另外一個物件中，交由這個物件去專門處理，我們稱這新物件為工廠。</li>
<li>5.定義簡單工廠</li>
<li>6.給衍生類別使用的框架</li>
<li>7.允許次類別做決定</li>
<li>8.藉由工廠方法，鬆綁超類別與次類別的關係</li>
<li>9.平行的類別階層</li>
<li>10.定義工廠方法模式：定義了一個建立物件的介面，但由次類別決定要實體化的類別為何者。工廠方法讓類別把實體化的動作，交由次類別進行。</li>
<li>11.顛覆依賴守則：依賴抽象類別，不依賴具象類別</li>
<li>A：變數不可持有具象類別的參考</li>
<li>B：不可讓類別繼承自具象類別</li>
<li>C：不可讓次類別中的方法 override 超類別的方法</li>
<li>12.定義抽象工廠模式：提供一個介面，建立相關或者相依物件之家族，而不需要明確指定具象類別</li>
<li>13.抽象工廠模式與工廠模式的不同</li>
<li>14.依賴抽象，不依賴具象類別</li>
<li>參考網址：https://wickedlysmart.com/headfirstdesignpatterns/code.html</li>

# 第五章 - 獨體模式
<li>1.認識獨體模式</li>
<li>2.特點：沒有公開的建構式，要實體這個類別，必須呼叫這類別其他方法(例如：getInstance() )來實體化該類別。</li>
<li>3.定義獨體模式：確保一個類別只有一個實體，並給他一個存取的全域點(global point)</li>
<li>4.多執行序和獨體模式</li>
<li>5.使用雙重檢查上鎖減少使用同步化</li>
<li>6.OO 守則：確保一個類別只有一個實體，並提供全域點存取此實體。</li>

# 第六章 - 命令模式
<li>1.介紹命令模式</li>
<li>2.定義命令模式：將「請求」封裝成物件，以便使用不同的請求、佇列、或者日誌，參數化物件。命令模式也支援可復原作業。</li>
<li>3.將命令模式套用進範例</li>
<li>4.空物件，NoCommand 物件是一個空物件的範例，當需要一個沒有任何意義值時，空物件非常有用，客戶可以將處理 null 的責任轉給空物件。</li>
<li>5.空物件本身也被視為一種設計模式</li>
<li>6.實踐 execute() 方法</li>
<li>7.實踐 undo() 方法</li>
<li>8.每個遙控器都具備「集合」形式</li>
<li>9.使用巨集命令</li>
<li>10.命令模式更多用途：佇列請求、日誌請求</li>

# 第七章 - 轉接器模式與表象模式
<li>1.介紹轉接器</li>
<li>2.解釋轉接器模式</li>
<li>3.定義轉接器模式：將一個類別的介面，轉換成為另外一個介面以供客戶使用。轉接器讓原本介面不相容的類別可以合作無間。</li>
<li>4.物件和類別轉接器</li>
<li>5.實作練習</li>
<li>6.裝飾者模式和轉接器模式相似與差異</li>
<li>7.介紹表象模式</li>
<li>8.轉接器模式的目的：改變介面符合客戶期望，表象模式目的：提供次系統一個簡化介面。</li>
<li>9.定義表象模式：提供一個統一介面，用來存取次系統中的一群介面。表象定義了一個較高層次的介面，讓次系統更容易使用。</li>
<li>10.設計原則：認識極少化守則：只和你的密友談話</li>

# 第八章 - 樣板方法模式
<li>1.將相同方法提出另做一個類別，該類別不同的方法抽象化，以提供給需要該方法的共同使用</li></li>
<li>2.在各自方法實作各自抽象化方法</li>
<li>3.認識樣板方法模式</li>
<li>4.樣板方法定義一個演算法步驟，並允許次類別為一個或多個步驟，提供其實鍵方式。</li>
<li>5.樣板方法模式：「將一個演算法的骨架定義在一個方法中，而演算法本身會用到一些方法，則是定義在次類別中。</li>
<li>樣板方法讓次類別在不改變演算法架構的情況下，重新定義演算法中的某些步驟。」
<li>6.對樣板方法使用掛鉤</li>
<li>7.好萊塢守則：「別呼叫(打電話給)我們，我們會呼叫(打電話給)你」
<li>8.好萊塢守則與樣板方法</li>
<li>9.用樣板方法排序
<li>10.樣板模式和策略模式的差別</li>
<li>11.策略模式：「訂一個演算法家族，並讓這些演算法可以互換。正因為每一個演算法都被封裝所以使用者可以輕易使用不同演算法」</li>
<li>樣板模式：「定義一個演算法大綱，交由次類別定義其中某些步驟內容，實踐不同細節但是演算法架構仍不變」</li>
<li>12.策略模式以及樣板方法模式都是用來封裝演算法，但是策略是用合成，樣板方法是用繼承。</li>
<li>13.工廠方法是樣板方法的一種特殊版</li>




