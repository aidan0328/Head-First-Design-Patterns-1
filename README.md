# Head First Design Patterns
<li>https://github.com/bethrobson/Head-First-Design-Patterns 作者 github</li>

# 第一章 - 介紹設計模式-歡迎到來設計模式
<li>1.介紹設計模式</li>
<li>2.類別與次類別之間的關係</li>
<li>3.繼承的缺失</li>
<li>4.把會變動的部分取出並「封裝」起來，好讓其他部份部受到影響。程式碼變動之後，出其不意的部分會變少，系統會變更有彈性。</li>
<li>5.分開變動和不會變動的部分</li>
<li>6.設計守則：寫程式是針對介面寫，而不是針對實踐方式寫</li>
<li>7.「寫程式是針對介面寫」真正的意思是「寫程式是針對超型態(supertype)而寫」</li>
<li>8.動態地設計行為</li>
<li>9.行為封裝的大局觀</li>
<li>10.設計守則：多用合成，少用繼承</li>
<li>11.「策略模式」：定義了演算法家族，個別封裝起來，讓它們之間可以互相替換。此模式讓演算法的變動，不會影響到使用演算法的程式</li>
<li>12.共通模式詞彙</li>

# 第二章 - 觀察者模式
<li>1.實做題目的需求</li>
<li>2.知道目前可以得到哪些資訊</li>
<li>3.認識觀察者模式</li>
<li>4.觀察者模式簡單定義：報社與訂閱者的關係，但報社有更新報紙就會給予訂閱者通知，反之沒有訂閱的就不會收到通知。</li>
<li>5.定義觀察者模式</li>
<li>6.觀察者模式類別圖</li>
<li>7.鬆綁</li>
<li>8.主題和觀察者的關係</li>
<li>9.使用 java 內建的觀察者模式</li>
<li>10.在 JDK 中找到觀察者模式</li>

# 第三章 - 裝飾者模式-裝飾物件
<li>1.類別爆炸時應該怎麼去規劃</li>
<li>2.開放關閉守則：類別開放以方便擴充，關閉禁止修改</li>
<li>3.認識裝飾者模式</li>
<li>4.定義裝飾者模式</li>
<li>5.真實世界的裝飾者 java I/O</li>
<li>6.設計自己的 java I/O 裝飾者</li>

# 第四章 - 工廠模式
<li>1.思考 new</li>
<li>2.實作範例</li>
<li>3.封裝建立物件</li>
<li>4.將會變動的程式碼封裝到另外一個物件中，交由這個物件去專門處理，我們稱這新物件為工廠。</li>
<li>5.定義簡單工廠</li>
<li>6.給衍生類別使用的框架</li>
<li>7.允許次類別做決定</li>
<li>8.藉由工廠方法，鬆綁超類別與次類別的關係</li>
<li>9.平行的類別階層</li>
<li>10.定義工廠方法模式：定義了一個建立物件的介面，但由次類別決定要實體化的類別為何者。工廠方法讓類別把實體化的動作，交由次類別進行。</li>
<li>11.顛覆依賴守則：依賴抽象類別，不依賴具象類別</li>
<li>A：變數不可持有具象類別的參考</li>
<li>B：不可讓類別繼承自具象類別</li>
<li>C：不可讓次類別中的方法 override 超類別的方法</li>
<li>12.定義抽象工廠模式：提供一個介面，建立相關或者相依物件之家族，而不需要明確指定具象類別</li>
<li>13.抽象工廠模式與工廠模式的不同</li>
<li>14.依賴抽象，不依賴具象類別</li>
<li>參考網址：https://wickedlysmart.com/headfirstdesignpatterns/code.html</li>

# 第五章 - 獨體模式
<li>1.認識獨體模式</li>
<li>2.特點：沒有公開的建構式，要實體這個類別，必須呼叫這類別其他方法(例如：getInstance() )來實體化該類別。</li>
<li>3.定義獨體模式：確保一個類別只有一個實體，並給他一個存取的全域點(global point)</li>
<li>4.多執行序和獨體模式</li>
<li>5.使用雙重檢查上鎖減少使用同步化</li>
<li>6.OO 守則：確保一個類別只有一個實體，並提供全域點存取此實體。</li>

# 第六章 - 命令模式
<li>1.介紹命令模式</li>
<li>2.定義命令模式：將「請求」封裝成物件，以便使用不同的請求、佇列、或者日誌，參數化物件。命令模式也支援可復原作業。</li>
<li>3.將命令模式套用進範例</li>
<li>4.空物件，NoCommand 物件是一個空物件的範例，當需要一個沒有任何意義值時，空物件非常有用，客戶可以將處理 null 的責任轉給空物件。</li>
<li>5.空物件本身也被視為一種設計模式</li>
<li>6.實踐 execute() 方法</li>
<li>7.實踐 undo() 方法</li>
<li>8.每個遙控器都具備「集合」形式</li>
<li>9.使用巨集命令</li>
<li>10.命令模式更多用途：佇列請求、日誌請求</li>

# 第七章 - 轉接器模式與表象模式
<li>1.介紹轉接器</li>
<li>2.解釋轉接器模式</li>
<li>3.定義轉接器模式：將一個類別的介面，轉換成為另外一個介面以供客戶使用。轉接器讓原本介面不相容的類別可以合作無間。</li>
<li>4.物件和類別轉接器</li>
<li>5.實作練習</li>
<li>6.裝飾者模式和轉接器模式相似與差異</li>
<li>7.介紹表象模式</li>
<li>8.轉接器模式的目的：改變介面符合客戶期望，表象模式目的：提供次系統一個簡化介面。</li>
<li>9.定義表象模式：提供一個統一介面，用來存取次系統中的一群介面。表象定義了一個較高層次的介面，讓次系統更容易使用。</li>
<li>10.設計原則：認識極少化守則：只和你的密友談話</li>

# 第八章 - 樣板方法模式
<li>1.將相同方法提出另做一個類別，該類別不同的方法抽象化，以提供給需要該方法的共同使用</li></li>
<li>2.在各自方法實作各自抽象化方法</li>
<li>3.認識樣板方法模式</li>
<li>4.樣板方法定義一個演算法步驟，並允許次類別為一個或多個步驟，提供其實鍵方式。</li>
<li>5.樣板方法模式：「將一個演算法的骨架定義在一個方法中，而演算法本身會用到一些方法，則是定義在次類別中。</li>
<li>樣板方法讓次類別在不改變演算法架構的情況下，重新定義演算法中的某些步驟。」
<li>6.對樣板方法使用掛鉤</li>
<li>7.好萊塢守則：「別呼叫(打電話給)我們，我們會呼叫(打電話給)你」
<li>8.好萊塢守則與樣板方法</li>
<li>9.用樣板方法排序
<li>10.樣板模式和策略模式的差別</li>
<li>11.策略模式：「訂一個演算法家族，並讓這些演算法可以互換。正因為每一個演算法都被封裝所以使用者可以輕易使用不同演算法」</li>
<li>樣板模式：「定義一個演算法大綱，交由次類別定義其中某些步驟內容，實踐不同細節但是演算法架構仍不變」</li>
<li>12.策略模式以及樣板方法模式都是用來封裝演算法，但是策略是用合成，樣板方法是用繼承。</li>
<li>13.工廠方法是樣板方法的一種特殊版</li>

# 第九章 - 反覆器與合成模式
<li>1.檢視問題(兩個不同物件如何合併)</li>
<li>2.封裝重複動作-使用反覆器</li>
<li>3.認識反覆器模式</li>
<li>4.定義反覆器模式：「讓我們能夠取得一個聚集內的每一個元素，而不需要此聚合將其實踐方式暴露。」</li>
<li>5.單一責任：「如果允許我們的聚集實踐他們內部的聚合，以及相關的操作和反覆的方法，又會如何?我們已經知道這會增加聚集的方法個數，但又怎樣?為什麼這麼做不好?」</li>
<li>6.設計守則：「一個類別應該只具有一個改變的理由」</li>
<li>7.類別的每個責任都有改變的淺在部分。超過一個責任就代表超過一個改變的淺在部分。這個守則告訴我們盡量讓每一個類別保持單一責任。</li>
<li>8.反覆器與聚合</li>
<li>9.定義合成模式：「允許你將物件合成樹狀結構，呈現「部分/整體」的階層關係。合成能讓客戶程式碼以一致的方式處理個別物件，以及合成的物件。」</li>
<li>10.合成模式讓我們能夠用樹狀方式建立物件的結構，樹裡面包含了合成以及個別的物件。</li>
<li>11.使用合成結構，我們能以相同的操作處理合成以及個別的物件。換句話說，在大多數情況下，我們可以忽略合成以及個別物件之間的差異。</li>
<li>12.透明性：讓元件的介面同時包含一些管理子節點的操作以及葉節點的操作，如此一來客戶就可以將合成節點和葉節點一視同仁，也就是說一個元素究竟是合成節點或者業節點，客戶看不到。</li>

# 第十章 - 狀態模式
<li>1.策略模式是建立可以改變的演算法。</li>
<li>狀態模式是藉由改變物件內部的狀態，幫助物件控制自己的行為。</li>
<li>2.劇情描述狀態模式</li>
<li>3.狀態模式的要點：</li>
<li>A：找出所有狀態</li>
<li>B：建立一個實體變數，持有目前狀態，然後定義每個狀態值</li>
<li>C：將所有的動作整合</li>
<li>D：建立一個類別，它的作用就像是一個狀態機。
<li>對每一個動作都建立一個對應的方法，這些方法利用條件描述決定出在每個狀態內甚麼行為是洽當的。</li>
<li>.通用技巧：在一個物件內為狀態改變建立模型。這個作法所用的技巧是利用物件內的一個實體變數持有狀態，並利用方法內的條件式程式碼轉換狀態。</li>
<li>5.定義狀態介面與類別</li>
<li>6.狀態模式：「允許物件隨著內在的狀態改變而改變行為，好像物件的類別改變一樣」</li>

# 第十一章 - 代理人模式
<li>1.簡介代理人模式</li>
<li>2.遠端代理人是「遠端物件的本地代表」。</li>
<li>3.何謂「遠端物件」?這是一種物件，活在不同的 JVM 記憶體堆積區(heap)中</li>
<li>4.何謂「本地代表」?這是一個可以在本地端調用的物件，其行為會被轉到遠端物件中施行。</li>
<li>5.你的客戶物件運作起來就像是呼叫遠端，但其實只是呼叫本地堆積區中的「代理人」物件，再由代理人處理網路溝通的低階細節。</li>
<li>6.使用和介紹 Java 套件 RMI</li>
<li>7.代理人執行運作的流程</li>
<li>8.RMI 術語： RMI 將客戶輔助物件稱為 Stub，服務輔助物件稱為 Skeletion。</li>
<li>9.製作遠端服務：</li>
<li>步驟一：製作遠端介面</li>
<li>步驟二：製作遠端實踐</li>
<li>步驟三：利用 RMIC 產生真正的 Stub 和 Skeleton</li>
<li>步驟四：開始 RMI Registry(rmiregistry)</li>
<li>步驟五：開始遠端服務</li>
<li>10.使用 RMI 常見錯誤：</li>
<li>錯誤一：忘記啟動遠端服務之前先啟動 Rmiregistry。(想要用 Naming.rebind()，就必須先啟動 Rmiregistry。)</li>
<li>錯誤二：忘記讓參數和傳出值得型態成為可序列化的型態。(該錯誤無法在編譯期間發現，只會在執行期發現)</li>
<li>錯誤三：忘記提供 Stub 類別給 Client 端使用</li>
<li>11.藉由調用代理人的方法，遠端方法的調用可以跨過網路，傳回字串、整數和狀態物件。</li>
<li>因為我們使用的是代理人，調用方法會在遠端執行，本低端根本就不知道或者不在乎這一點(唯一例外就是：要處理遠端例外)</li>
<li>12.定義代理人模式：讓某個物件具有一個替身，藉以控制外界對此物件的接觸。</li>
<li>13.使用代理人模式建立代表物件，讓代表物件控制某物件的存取，被代理的物件可以是遠端的物件，建立成本高的物件或者需要安全控管的物件。</li>
<li>14.簡介虛擬代理人</li>
<li>15.簡述保護代理人</li>
<li>16.動態代理人：</li>
<li>步驟一：建立兩個 InvocationHandler</li>
<li>步驟二：寫程式碼建立動態代理人</li>
<li>步驟三：利用適當的代理人包裝任何 PersonBean 物件</li>

# 第十二章 - 複合模式
<li>1.模式通常被一起使用，並在同一個設計問題上攜手合作。</li>
<li>2.複合模式：「結合兩個或多個模式再一起解決方案，以解決一般或者常發生的問題。」</li>
<li>3.簡短複習各種模式</li>
<li>4.認識複合模式代表 MVC(Model-View-Controller)</li>
<li>5.model 利用「觀察者模式」讓 controller 和 View 可以得知狀態的改變。</li>
<li>6.View 和 controller 則是實踐「策略模式」，controller 是 View 的行為，不同的行為可以換不同的 controller。</li>
<li>7.View 內部使用「合成模式」管理諸多視覺化控件。</li>
<li>8.MVC-WEB 的關係與 MVC-APP 的關係</li>
<li>9.Model 2 Controller Servle 的介紹</li>
<li>10.Model 2 模式</li>
