一、橋梁模式(Bridge Patterm)
1.橋梁模式：使用橋梁模式(Bridge Patterm)不只改變你的實踐方式，也能改變你的抽象。
2.為何使用橋梁模式?因為橋梁模式允許你改變實踐以及抽象，採取的作法是：將實踐和抽象放在兩個不同類別層階中。
3.橋梁的優點：
A：將實踐予以鬆綁，讓他和介面之間不在是永恆的狀態。
B：抽象和實踐可以被各自擴充，不會影響到對方。
C：對於「具象的抽象類別」所做的改變，不會影響到客戶
4.橋梁的用途以及缺點：
A：相當適用使用在需要誇越多個平台的圖形和視窗系統上。
B：當你需要用不同的方式改變介面以及實現時，你會發現橋梁模式很好用。
C：橋梁模式的缺點就是增加複雜度。

二、建立者模式(Builder Patterm)
1.建立者模式：使用建立者模式(Builder Patterm)封裝一個產品的建構過程，並允許可依照步驟建構。
2.為何使用建立者模式?因為我們可以將反覆的過程封裝進一個物件中，並將內部收集的資料結構隱藏，讓客戶看不到
3.建立者的優點：
A：將一個複雜物件的建立過程封裝起來。
B：允許物件在多個步驟建立，並且可以改變程序(這和只有一個步驟的工廠方法不相同)
C：將產品內部的表現方式隱藏起來，但客戶無法碰觸。
D：產品的實踐方式可以被替換，因為客戶只可以看到抽象的介面。
4.建立者的用途和缺點：
A：經常被用來建立合成結構。
B：和工廠模式相較，採用建立者模式建立物件的客戶，需要具備更多的特定領域知識。

三、責任鏈(Chain of Responsibility Patterm)
1.當你想要讓一個以上的物件，有機會能夠處理某個請求之時候，就可以使用責任鏈模式(Chain of Responsibility Patterm)。
2.為何使用責任鏈模式?透過責任鏈模式，你可以對某個請求感興趣的物件建立一個鏈結，每個物件依序檢視此請求並處理之，或者是將他轉給連結中的下一個物件處理。
3.責任鏈的優點：
A：將請求地發出者和接受者之間予以鬆綁。
B：可以簡化你的物件，因為它不需要知道此鏈結的結構。
C：允許動態新增或者刪除責任，你可以改變鏈結的某個處理城市，或者它們的秩序。
4.責任鏈的用途和缺點：
A：經常被使用在視窗系統中，處理像是滑鼠和鍵盤的事件。
B：並不保證請求一定會被執行，如果沒有任何物件處理他的話，可能會落到鏈結尾端以外(這可以是優點也可以是缺點。)
C：可能不容易觀察執行期的行為，有礙於除錯。

四、蠅量級(Flyweight Pattern)
1.蠅量級模式(Flyweight Pattern)：想讓某個類別的一個實體，能夠提供許多「虛擬實體」。
2.為何使用蠅量級模式?如果不用責任鏈模式，你可以重心設計系統，只能用一個實體和一個客戶物件，維護「所有」實體狀態。
3.蠅量級的優點：
A：大幅縮減執行期物件的個數，節省記憶體。
B：將許多「虛擬」物件的狀態集中管理。
4.蠅量級的用途和缺點：
A：當一個類別有許多的實體，而這些實體可以能夠被一致的方法控制的時候，就可以使用蠅量級模式。
B：蠅量級模式的缺點在於，一旦你實踐了他，那所有邏輯的實體，將無法擁有獨立而不同的行為。

五、翻譯者模式(Interpreter Pattem)
1.翻譯者模式(Interpreter Pattem)：為語言建立翻譯者。
2.為何使用翻譯者模式?當你需要實踐一個簡單的語言，那就使用翻譯者模式定義文法的類別，並用一個翻譯者翻譯句子。每個文法規則都用一個類別代表。
3.翻譯者模式的優點：
A：將每一個文法規則設定成一個類別，方便於實踐語言。
B：因為文法就是許多類別的集合，所以你可以輕易改變並擴充此語言。
C：藉由在類別結構中加入新的方法，可以在翻譯者的同時增加新的行為，例如輸出格式的美化，或者進行複雜的程式檢查。
4.翻譯者的用途和缺點：
A：當你需要實踐一個簡單的語言時，使用翻譯者模式。
B：當你有一個簡單的文法，而且簡單比效率來的重要時。
C：可以處理編劇語言以及編成語言。
D：當文法規則的數目太大時，這個模式可能變得非常繁雜。在這種情況下，使用剖析器/編譯器的產生器可能更為適合。

六、居間協調者(Mediator Pattern)
1.居間協調者(Mediator Pattern)：將相關的物件之間，複雜的溝通和控制方式予以簡化。
2.每個物件都會在自己的狀況改變時，通知居間協調者。
3.每個物件都會對居間協調者所發出的請求做出回應。
4.居間協調者的優點：
A：藉由將物件彼此鬆綁，可以增加物件的再利用性。
B：藉由將控制邏輯中央集權化，可以簡化系統維護。
C：可以讓物件之間所傳遞的訊息變得更簡單而且大幅減少。
5.居間協調者的用途與缺點
A：協調者常常被用來協調相關的 GUI 元件。
B：距今協調者模式的缺點是如果涉及不當的話，居間協調者本身會變得過於複雜。

七、助記物(Memento Pattern)
1.助記物(Memento Pattern)：當你需要讓物件返回之前的狀態時(例如，你的使用者發出「復原」的請求)。
2.使用助記物有兩個目標：
A：儲存系統關鍵物件的重要狀態。
B：維護關鍵物件的封裝。
3.助記物的優點：
A：將被儲存的狀態放在外面，不要和關鍵物件混在一起，這可以幫助維護內聚力。
B：讓關鍵物件的資料封裝不受破壞。
C：提供容易實踐的恢復能力。
4.助記物的用途與缺點：
A：助記物是儲存狀態。
B：使用助記物的缺點在於儲存和回復狀態的過程可能相當耗費時間。
C：在 Java 系統中，期時可以使用序列化(Serialization)機制儲存系統的狀態。

八、雛形(Prototype Pattern)
1.雛形模式(Prototype Pattern)：當建立物件實體的過程很昂貴或很複合。
2.雛型模式允許你藉由複製現有的實體，建立新的實體(在 Java 中，這通常意味著使用 clone() 方法，或者反序列化)。這個模式重點在於，客戶的程式碼在不知道特定類別違和之情況下，仍可以製造出新的實體。
3.雛形的優點：
A：將製造新實體過程中複雜的一切隱藏起來，讓使用者無需面對。
B：讓客戶能夠產生未知類別的實體。
C：在某些環境下，複製物件比建立物件更有效率。
4.雛形的用途與缺點：
A：在一個複雜的類別階層架構中，當系統必須從其中的許多類別產生實體化的物件時，可以考慮使用雛型模式。
B：使用雛型模式的缺點在於物件的複製過程有時候相當複雜。

九、參觀者(Visitor Pattern)
1.參觀者(Visitor Pattern)：當你想要為一個合成增加新的能力，且封裝並不重要時。
2.參觀者必須參觀合成內所有元素，這樣的功能是在旅遊者(Traverser)物件中，參觀者藉由旅遊者的引導，收集合成中所有物件的狀態。
3.一旦狀態被收集完成，客戶就可以讓參觀者對狀態進行各種操作。當需要新功能時，只要加強參觀者即可。
4.參觀者的優點：
A：允許你對合成結構加入新的操作，而無須改變結構本身。
B：想要加入新的操作相當容易。
C:參觀者所進行的操作，程式碼是集中在一起的。
5.參觀者的用途與缺點：
A：當採用參觀者模式的時候，就會打破合成類別的封裝。
B：因為旅遊的功能牽涉其中，所以對合成結構的改變更為複雜。
